
'''
Created on 2013-11-29

@author: gjwang
'''

from BitTorrent.makemetafile import make_meta_files
from BitTorrent.parseargs import parseargs, printHelp
from BitTorrent import BTFailure
from sha import *
from BitTorrent.bencode import *

from twisted.web import server, resource
from twisted.web.server import Site
from twisted.web.server import NOT_DONE_YET
from twisted.web.resource import Resource
from twisted.web.client import HTTPDownloader
from twisted.web.client import downloadPage
from twisted.web.client import Agent
from twisted.web.http_headers import Headers
from twisted.internet import reactor


import os
import copy
import urllib2
from urlparse import urlsplit
from os.path import join, dirname, basename, normpath, splitext, getsize, dirname
from os import errno
import logging

import hashlib
md5 = hashlib.md5

import json
import cgi
from conf import wwwroot, maketorent_config, response_msg, http_prefix, node_domain, bt_user, bt_password

from conf import MAX_MAKETORRENT_TASKS, AM_I_MK_METAINFO_SERVER

bt_password = md5(bt_password).hexdigest()

#TODO: for temp use; maybe can use twisted.cred, twisted.web.guard... instead
def validate(func):
    def __decorator(self, request):
        user = request.args.get('user')
        pwd = request.args.get('pwd')        

        if (user and user[0]== bt_user) and (pwd and pwd[0].lower() == bt_password):
            return func(self, request)
        else:
            request.setResponseCode(401)
            logger = logging.getLogger()
            logger.error("login errro: user:%s, pwd:%s", user, pwd)
            return 'Unauthorized'

    return __decorator  

def return_request(request, msg):
    msg = json.dumps(msg, indent=4, sort_keys=True, separators=(',', ': '))        
    request.write(msg)
    request.finish()


class Ping(Resource):
    @validate
    def render_GET(self, request):
        return 'PONG'
    
    def render_POST(self, request):
        return self.render_GET(request)


class AsyncDownloader():
    def __init__(self, topdir, multidl, url, request, msg, filesize = None, localfilename = None):
        self._logger = logging.getLogger(self.__class__.__name__)

        self.topdir = topdir
        self.node_domain = node_domain
        self.multidl = multidl
        self.url = url
        self.request = request
        self.msg = msg
        self.filesize = filesize
        self.localtorrentfile = None

        if localfilename is None:
            f = join(self.topdir, urlsplit(self.url).path[1:])
            if splitext(f)[1].lower() == '.torrent':
                self.localtorrentfile = f
                self.localfilename = splitext(f)[0]
            else:
                self.localfilename = f
        else:            
            self.localfilename = localfilename
            if splitext(self.url)[1].lower() == '.torrent':
                self.localtorrentfile = splitext(self.url)[0]
            
        self.msg['args']['filenmae'] = self.localfilename
        self.msg['args']['fileurl'] = self.localfilename.replace(self.topdir, self.node_domain)
        self.msg['args']['torrentfile'] =  self.localtorrentfile

    def return_request(self, request, msg):
        msg = json.dumps(msg, indent=4, sort_keys=True, separators=(',', ': '))        
        request.write(msg)

        try:
            request.finish()
        except Exception as e:
            #connection maybe already lost
            self._logger.info('AsyncDownloader return_request exception: %s', e)


    def download_done(self, context, msg):
        if self.localtorrentfile:
            self.add_task_to_multidl(msg)
        else:
            msg['result'] = 'failed'
            msg['traceback'] = "No torrent file: %s" % self.localtorrentfile
            self._logger.error(msg['traceback'])
            self.return_request(self.request, msg)

    def error_handler(self, error, msg = None):
        if msg is None:
            copy.deepcopy(self.msg)#make a new copy of response_msg        

        msg['result'] = 'failed'         
        msg['traceback'] = "download %s Exception: %s" % (self.url, str(error))    
        self._logger.error(msg['traceback'])    

        self.return_request(self.request, msg)

    def add_task_to_multidl(self, msg):
        try:
            sha1 = msg['args'].get('sha1')
            if sha1 and self.multidl.dls.has_key(sha1):
                dl, _= self.multidl.dls[sha1]

                status = dl.get_activity()
                if status == 'seeding' or status == 'download succeeded':
                    msg["args"]["percent"] = 100
    
                msg['result'] = 'success'
                msg['status'] = status
                msg['traceback'] = 'sha1:%s is already %s' % (sha1, status)

                self._logger.error(msg['traceback'])
                self.return_request(self.request, msg)
                return
            
            for (hash_info, (dl, f)) in self.multidl.dls.items():
                if f == self.localtorrentfile:
                    status = dl.get_activity()
                    if status == 'seeding' or status == 'download succeeded':
                        msg["args"]["percent"] = 100

                    msg['result'] = 'success'
                    msg['status'] = status
                    msg['traceback'] = 'file:%s is already %s' % (self.localtorrentfile,  status)

                    self._logger.error(msg['traceback'])
                    self.return_request(self.request, msg)
                    return

            try:
                self._logger.info("btdown %s to %s", self.localtorrentfile, self.localfilename)

                dl_config = {}
                dl_config['save_as'] = self.localfilename

                dl = self.multidl.add_task(msg.get('taskid'), torrentfile=self.localtorrentfile,
                                           singledl_config = dl_config, sha1=sha1)

                msg['status'] = dl.get_activity()
                msg['result'] = 'success'
            except Exception as e:
                msg['result'] = 'failed'
                msg['traceback'] = "multidl.add_dl Execption: %s" % str(e)
                self._logger.error(msg['traceback'])
                self._logger.exception("multidl.add_dl Execption")

        except Exception as e:
            msg['result'] = 'failed'
            msg['traceback'] = "add_task_to_multidl Execption: %s" % str(e)

            self._logger.error(msg['traceback'])

	self._logger.info('addtask response: %s', msg)	
        self.return_request(self.request, msg)


    def makedir(self):
        dstdirname = dirname(self.localfilename)
        try:
            if not os.path.exists(dstdirname):
                os.makedirs(dstdirname)
        except Exception, exc:
            msg = {}
            msg['result'] = 'failed'
            msg['traceback'] = str(exc)
            self._logger.error("mkdir: %s failed: %s", dstdirname, exc)
            self.return_request(self.request, msg)
            return False
        else:
            return True

    def start(self, redownload=True):
        '''
            redownload: redownload torrent file or not
        '''

        if self.makedir() == False:
            return 

        if redownload:
            deferred = downloadPage(bytes(self.url), self.localtorrentfile)
            deferred.addCallback(self.download_done, self.msg)
            deferred.addErrback(self.error_handler, self.msg)
            self._logger.info("download %s to %s", self.url, self.localtorrentfile)
        else:
            self.download_done(context=None, msg=self.msg)

class FormPage(Resource):
    @validate
    def render_GET(self, request):
        return '<html><body><form method="POST"><input name="the-field" type="text" /></form></body></html>'

    @validate
    def render_POST(self, request):
        return '<html><body>You submitted: %s</body></html>' % (cgi.escape(request.content.read()),)


def rmfile_and_emptypath(task, msg, request):
    logger = logging.getLogger()

    args = task.get('args') or {}

    torrentfileurl = args.get('torrentfileurl')    
    topdir = args.get('wwwroot') or wwwroot #global var wwwroot
    localname = args.get('filename')

    if localname is None or localname == '':
        if torrentfileurl is None or torrentfileurl == '':
            msg['result'] = 'failed'
            msg['traceback'] = "not specify delete file"
            logger.error('rm file failed: %s', msg['traceback'])
            return_request(request, msg)            
            return 

        torrentfile = join(topdir, urlsplit(torrentfileurl).path[1:])
        localname = splitext(torrentfile)[0]
    else:
        torrentfile = localname + '.torrent'
    
    msg['event'] = 'delete_response'
    msg['result'] = 'success'

    for f in (torrentfile, localname):
        if os.path.exists(f):
            try:
                os.remove(f)
                msg['result'] = 'success'
                logger.info('rm file success: %s', f)
            except OSError as ex:
                msg['result'] = 'failed'
                msg['traceback'] += "rmfile %s failed: %s; "%(f, ex)
                logger.error('rm file failed: %s', msg['traceback'])
        else:
            msg['traceback'] += 'file %s not exists; '% f
            logger.error('rm file failed: %s ', msg['traceback'])

    #rm empty dir, avoid empty 'holes'
    try:
        os.removedirs(dirname(localname))
    except OSError as ex:
        if ex.errno == errno.ENOTEMPTY:
            pass
        else:
            msg['result'] = 'failed'
            msg['traceback'] += "rmdir %s exception: %s"% (dirname(localname), ex)
            logger.error('rm dir failed: %s', msg['traceback'])

    return_request(request, msg)
    

class PutTask(Resource):
    tasknum = 0
    def __init__(self, multidl):
        self._logger = logging.getLogger(self.__class__.__name__)

        self.multidl = multidl
        self.wwwroot = wwwroot #global var wwwroot
        self.response_msg = response_msg


    def return_request(self, request, msg):
        msg = json.dumps(msg, indent=4, sort_keys=True, separators=(',', ': '))        
        request.write(msg)
        request.finish()


    @validate        
    def render_GET(self, request):
        self._logger.info('recv get request')
        return '<html><body><form method="POST"><input name="the-field" type="text" /></form></body></html>'

    @validate
    def render_POST(self, request):
        self.tasknum += 1
        content = cgi.escape(request.content.read())
        self._logger.info('PutTask: %s', content)

        msg = copy.deepcopy(self.response_msg)#make a new copy of response_msg
        msg['event'] = 'puttask_response'

        task = {}
        try:
            task = json.loads(content)
        except Exception as e:
            msg['result'] = 'failed'
            msg['traceback'] = "json format error,  Exception: %s" % str(e)
            self._logger.error(msg['traceback'])
            msg = json.dumps(msg, indent=4, sort_keys=True, separators=(',', ': '))
            return msg

        event = task.get('event')        
        msg['taskid'] = task.get('taskid') or ''

        if event == 'download':
            taskargs = task.get('args') or {}
            torrentfileurl = taskargs.get('torrentfileurl')

            if torrentfileurl is None:
                msg['result'] = 'failed'
                msg['traceback'] = "undefine torrentfileurl"
                msg = json.dumps(msg, indent=4, sort_keys=True, separators=(',', ': '))
                return msg

            msg['event'] = 'download_response'            
            msg['args']['torrentfileurl'] = torrentfileurl
            msg['args']['sha1'] = taskargs.get('sha1')

            topdir = taskargs.get('wwwroot') or self.wwwroot
            
            try:
                adl = AsyncDownloader(topdir, self.multidl, torrentfileurl, request, msg)
                adl.start(redownload = not AM_I_MK_METAINFO_SERVER)
                return NOT_DONE_YET
            except Exception as e:
                #msg = {}
                msg['result'] = 'failed'
                msg['traceback'] = "AsyncDownloader Exception: %s" % str(e)
        elif event == 'delete':
            try:
                rmfile_and_emptypath(task, msg, request)
                return NOT_DONE_YET
            except Exception as e:
                #msg = {}
                msg['event'] = 'delete_response'
                msg['result'] = 'failed'
                msg['traceback'] = "Exception: %s" % str(e)
        else:
            #msg = {}
            msg['result'] = 'failed'
            msg['traceback'] = "unknown event: %s" % event

        self._logger.error(msg['traceback'])                            
        msg = json.dumps(msg, indent=4, sort_keys=True, separators=(',', ': '))        
        return msg


class MakeTorrent(Resource):
    tasknum = 0
    concurrent = 0

    def __init__(self, multidl):
        self._logger = logging.getLogger(self.__class__.__name__)

        self.agent = Agent(reactor)

        self.multidl = multidl
        self.wwwroot = wwwroot #global var wwwroot
        self.maketorent_config = maketorent_config
        self.http_prefix = http_prefix
        self.response_msg = response_msg

    def return_request(self, request, msg):
        msg = json.dumps(msg, indent=4, sort_keys=True, separators=(',', ': '))        
        request.write(msg)

	self.concurrent = self.concurrent - 1 if self.concurrent > 0 else self.concurrent
        self._logger.info('left maketorrent concurrent = %d', self.concurrent)

	try:
            request.finish()
	except Exception as e:
	    #connection maybe already lost
	    self._logger.info('maketorrent return_request exception: %s, filename:%s',
				 e, msg['args'].get('filename'))	

    def maketorrent(self, filename, request, msg):
        self._logger.debug('Going to make torrent: %s', filename)

        def dc(v):
            #print v
            pass

        def prog(amount):
            #print '%.1f%% complete\r' % (amount * 100),
            #self._logger.debug('%.1f%% complete', amount * 100)
            pass

        config = self.maketorent_config
	trackers = msg['args']['trackers']
	if trackers:
	    tracker = trackers[0]
	else:
            tracker = config['tracker_name']
	    msg['trackers'] = [tracker]

        try:
            meta = make_meta_files(bytes(tracker),
                            [filename],
                            progressfunc=prog,
                            filefunc=dc,
                            piece_len_pow2=config['piece_size_pow2'],
                            comment=config['comment'],
                            target=config['target'],
                            filesystem_encoding=config['filesystem_encoding'],
                            use_tracker=config['use_tracker'],
                            data_dir=config['data_dir'])


            metainfo_file = open(filename + '.torrent', 'rb')
            metainfo = bdecode(metainfo_file.read())
            metainfo_file.close()
            info = metainfo['info']
            info_hash = sha(bencode(info))

            msg['args']['sha1'] = info_hash.hexdigest()
            msg['result'] = 'success'
        except BTFailure, e:
            msg['result'] = 'failed'
            msg['traceback'] = "Excepition BTFailure: %s" % str(e)
        except Exception, e:
            msg['result'] = 'failed'         
            msg['traceback'] = "make_meta_files failed: %s" % str(e)

        if msg['result'] == 'failed':            
            self._logger.error(msg['traceback'])
        else:
            self._logger.info("make_meta_files: %s success, sha1: %s", filename + '.torrent', msg['args']['sha1'])

        self.return_request(request, msg)
        
    @validate        
    def render_GET(self, request):
        self._logger.info("recv get request")
        return '<html><body><form method="POST"><input name="the-field" type="text" /></form></body></html>'

    @validate
    def render_POST(self, request):
        self.tasknum += 1
        content = cgi.escape(request.content.read())
        task = {}

        self._logger.info("MakeTorrent: %s", content)

        try:
            task = json.loads(content)
        except Exception as e:
            msg = {}
            msg['event'] = 'maketorrent_response'
            msg['result'] = 'failed'
            msg['traceback'] = "maketorent: json format error"

            self._logger.error("maketorent: json format error, Exception:%s", str(e))

            msg = json.dumps(msg, indent=4, sort_keys=True, separators=(',', ': '))        
            return msg

        event = task.get('event')

        msg = copy.deepcopy(self.response_msg)#make a new copy of response_msg
        msg['taskid'] = task.get('taskid') or ''
        msg['event'] = 'maketorrent_response'
        
        if event == 'maketorrent':
            try:
                args = task.get('args') or {}
                fileurl = args.get('fileurl')

                if fileurl is None:
                    msg['result'] = 'failed'
                    msg['traceback'] = "undefine fileurl in args"

                    self._logger.info("maketorrent_response: %s", msg['traceback'])

                    msg = json.dumps(msg, indent=4, sort_keys=True, separators=(',', ': '))
                    return msg

		trackers = args.get('trackers')
		if trackers and type(trackers) is not list:
		    msg['result'] = 'failed'
                    msg['traceback'] = "trackers must be json array"

                    self._logger.info("maketorrent_response: %s", msg['traceback'])

                    msg = json.dumps(msg, indent=4, sort_keys=True, separators=(',', ': '))
                    return msg 

                topdir = args.get('wwwroot') or self.wwwroot
                filename  = args.get('filename')
                path = urlsplit(fileurl).path[1:]
                if filename:
                    localfilename = join(topdir, filename)
                    path = filename
                elif path:
                    localfilename = join(topdir, path)
                else:
                    msg['result'] = 'failed'
                    msg['traceback'] = "uneffective url path or undefine filename"
                    self._logger.info("maketorrent_response: %s", msg['traceback'])
                    msg = json.dumps(msg, indent=4, sort_keys=True, separators=(',', ': '))
                    return msg
                    
                args_rsp = msg['args']
                args_rsp['filename'] = localfilename
                args_rsp['torrentfile'] = localfilename + '.torrent'
                args_rsp['torrentfileurl'] = join(self.http_prefix, path) + '.torrent'
		args_rsp['trackers'] = trackers
	
                d = self.agent.request(
                        'GET',
                        bytes(fileurl),
                        Headers({'User-Agent': ['Twisted Web Client'],
                                 'Content-Type': ['text/plain']}),
                        #body
                        )

                def cbRequest(response):
                    msg['args']['filesize'] = response.length
                    if os.path.exists(localfilename):
                        if response.length == getsize(localfilename):
                            self._logger.info("maketorrent: %s already exist, and filesize(%s) equals", 
                                                            localfilename, response.length)
                            self.maketorrent(localfilename, request, msg)
                        else:
                            self._logger.error("maketorrent: %s already exist, but filesize(%s)!=response.length(%s), redownload", 
                                               localfilename, getsize(localfilename), response.length)
                            self.downloadfile(request, fileurl, localfilename, msg)
                    else:
                        self.downloadfile(request, fileurl, localfilename, msg)
                    
                def cbErrRequest(error):
                    msg['result'] = 'failed'
                    msg['traceback'] = "Get filesize error: %s" % error
                    self.return_request(request, msg)

		if self.concurrent + 1 > MAX_MAKETORRENT_TASKS:
                    msg['result'] = 'failed'
                    msg['traceback'] = "Reached max(%s) maketorrent concurrent" % MAX_MAKETORRENT_TASKS
                    self._logger.error("maketorrent_response: %s", msg['traceback'])
                    msg = json.dumps(msg, indent=4, sort_keys=True, separators=(',', ': '))
                    return msg


                self.concurrent += 1
                self._logger.info('add maketorrent concurrent = %d', self.concurrent)

                d.addCallback(cbRequest)
                d.addErrback(cbErrRequest)
                
                return NOT_DONE_YET
            except Exception as e:
                msg['result'] = 'failed'
                msg['traceback'] = "Exception: %s" % str(e)
                self._logger.exception("maketorrent_response: %s", msg['traceback'])
                msg = json.dumps(msg, indent=4, sort_keys=True, separators=(',', ': '))
                return msg
        else:  
            #msg = {}
            msg['result'] = 'failed'
            msg['traceback'] = "unknown event: %s" % event
            self._logger.error("maketorrent_response: %s", msg['traceback'])
            msg = json.dumps(msg, indent=4, sort_keys=True, separators=(',', ': '))
            return msg

        self._logger.error("maketorrent_response: should not be here")
        return 'should not be here'

    def downloadfile(self, request, fileurl, localfilename, msg):
        dstdirname = dirname(localfilename)
        if not os.path.exists(dirname(localfilename)):
            os.makedirs(dstdirname)

	tmpfile = localfilename + '.tmp'
        self._logger.info("Going to download %s to tmpfile=%s", fileurl, tmpfile)

        deferred = downloadPage(bytes(fileurl), tmpfile)
        deferred.addCallback(self.download_done, localfilename, tmpfile, request, msg)
        deferred.addErrback(self.error_handler, request, msg)

    def download_done(self, context, filename, tmpfile, request, msg):
        if getsize(tmpfile) != msg['args']['filesize']:
            #TODO: should redownload the file
            self._logger.error("download: %s failed: filesize(%d)!=response.length(%d)", 
                                tmpfile, getsize(tmpfile), msg['args']['filesize'])
            msg['result'] = 'failed'
            msg['traceback'] = "download: %s failed: filesize(%d)!=response.length(%d)" % (tmpfile, getsize(tmpfile), msg['args']['filesize'])
            self.return_request(request, msg)
            return
        else:
            self._logger.info("download: %s done, and filesize(%d)=response.length", tmpfile, getsize(tmpfile))

	self._logger.info("rename %s to %s", tmpfile, filename)
	os.rename(tmpfile, filename)

	if getsize(filename) == msg['args']['filesize']:
            self.maketorrent(filename, request, msg)
        else:
            #TODO: should redownload the file
            self._logger.error("rename: %s filesize change: filesize(%d)!=response.length(%d)",
                                filename, getsize(filename), msg['args']['filesize'])
            msg['result'] = 'failed'
            msg['traceback'] = "download: %s failed: filesize(%d)!=response.length(%d)" % (filename, getsize(filename), msg['args']['filesize'])
            self.return_request(request, msg)
            return            

    def error_handler(self, error, request, msg = None):
        if msg is None:
            msg = copy.deepcopy(self.response_msg)#make a new copy of response_msg        
        msg['result'] = 'failed'         
        msg['traceback'] = "%s" % str(error)
        self._logger.error('download failed: result=%s, filename=%s, traceback=%s',
				 msg['result'], msg['args']['filename'], msg['traceback'])

        self.return_request(request, msg)
               


class ShutdownTask(Resource):
    def __init__(self, multidl):
        self._logger = logging.getLogger(self.__class__.__name__)

        self.multidl = multidl
        self.wwwroot = wwwroot #global var wwwroot
        self.response_msg = response_msg

    def return_request(self, request, msg):
        msg = json.dumps(msg, indent=4, sort_keys=True, separators=(',', ': '))        
        request.write(msg)
        request.finish()

    @validate
    def render_GET(self, request):        
        return '<html><body><form method="POST"><input name="the-field" type="text" /></form></body></html>'

    @validate    
    def render_POST(self, request):
        content = cgi.escape(request.content.read())

        self._logger.info('ShutdownTask: %s', content)

        task = {}
        try:
            task = json.loads(content)
        except Exception as e:
            self._logger.info('ShutdownTask json format error: %s', str(e))
            return "json format error"
        
        event = task.get('event')
        taskid = task.get('taskid') or ""

        msg = copy.deepcopy(self.response_msg)#make a new copy of response_msg        

        msg['taskid'] = taskid

        if event == 'shutdown':
            msg['event'] = 'shutdown_response'

            taskargs = task.get('args') or {}
            torrentfileurl = taskargs.get('torrentfileurl')
            sha1 = taskargs.get('sha1')
            topdir = taskargs.get('wwwroot') or self.wwwroot

            if sha1 or torrentfileurl:
                if torrentfileurl:
                    torrentfile = join(topdir, urlsplit(torrentfileurl).path[1:])
                else:
                    torrentfile = None

                try:
                    self.multidl.shutdown(sha1=sha1, torrentfile=torrentfile)
                    msg['result'] = 'success'
                except Exception as e:
                    msg['result'] = 'failed'
                    msg['traceback'] = str(e)                                    
            else:
                msg['result'] = 'failed'
                msg['traceback'] = "shutdown: not specify sha1 or file"
        elif event == 'shutdownall':
            msg['event'] = 'shutdownall_response'
            try:
                self.multidl.shutdown()
                msg['result'] = 'success'
            except Exception as e:
                msg['result'] = 'failed'
                msg['traceback'] = str(e)
        else:                
            #msg['event'] = 'shutdown_response'
            msg['result'] = 'failed'
            msg['traceback'] = "unknown event: %s" % event

        self._logger.info(msg)            
        msg = json.dumps(msg, indent=4, sort_keys=True, separators=(',', ': '))        
        return msg


if __name__ == "__main__":
    
    root = Resource()
    root.putChild("form", FormPage())
    root.putChild("ping", Ping())
    root.putChild("puttask", PutTask())
    root.putChild("shutdowntask", ShuddownTask())
    
    factory = Site(root)
    reactor.listenTCP(8090, factory)
    #reactor.run()    
    p = Process(target=reactor.run)
    p.start()
    print 'site is runnning...'
    p.join()

    
    
